program Practice;

{$APPTYPE CONSOLE}

{$R *.res}

uses
  System.SysUtils;

type
  TWeekDay = (Mon, Tue, Wed, Thu, Fri, Sat);
  TWorkHours = record
    start: TTime;
    finish: TTime;
  end;
  TSchedule = array[TWeekDay] of TWorkHours;
  TTalonListPt = ^TTalonlist;
  TTalon = Record
    date: Tdate;
    time: TTime;
    queuePos: integer;
    patientLastName: String;
    cabNum: Integer;
    docKey: Integer;
  End;
  TTalonList = record
    Talon: TTalon;
    next: TTalonListPt;
  end;
  TDocListPt = ^TDocList;
  TDoc = record
    docKey: Integer;
    specialisation: String;
    docLastName: String;
    Schedule: TSchedule;
  end;
  TDocList = record
    Doc: TDoc;
    next: TDocListPt;
  end;
  TTalonSearchComp = function(temp: TTalonListPt; const Value): boolean; 
  TTalonArr = array of TTalonListPt;

const
  WeekNames: array[TWeekDay] of String = ('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday');
  MonthDays: array[1..12] of integer = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

function isDigit(c: char): boolean;
begin
  result := (c >= '0') and (c <= '9');
end;

function correctDate(s: string): boolean;
var
  D, M, Y: integer;
begin
  result := true;
  if length(s) <> 10 then
    result := false
  else if (s[3] <> '.') or (s[6] <> '.') then
    result := false
  else if not(isDigit(s[1]) and isDigit(s[2]) and isDigit(s[4]) and isDigit(s[5]) and
    isDigit(s[7]) and isDigit(s[8]) and isDigit(s[9]) and isDigit(s[10])) then
    result := false
  else
  begin
    D := StrToInt(Copy(S, 1, 2));
    M := StrToInt(Copy(S, 4, 2));
    Y := StrToInt(Copy(S, 7, 4));
    if (Y = 0) or (M = 0) or (D = 0) then
      result := false;
    if (Y < 1900) or (Y > 2025) then
      result := false;
    if M > 12 then
      result := false;
    if D > MonthDays[M] then
      if not ((M = 2) and ((Y mod 400 = 0) or ((Y mod 100 <> 0) and (Y mod 4 = 0))) and (D <= 29)) then
        result := false;
  end;
end;

function correctTime(s: string): boolean;
var
  H, M: integer;
begin
  result := true;
  if length(s) <> 5 then
    result := false
  else if (s[3] <> ':') then
    result := false
  else if not(isDigit(s[1]) and isDigit(s[2]) and isDigit(s[4]) and isDigit(s[5])) then
    result := false
  else
  begin
    H := StrToInt(Copy(S, 1, 2));
    M := StrToInt(Copy(S, 4, 2));
    if M > 59 then
      result := false;
    if H > 24 then
      result := false;
  end;
end;

procedure InputDate(AMessage, AWrongMessage: String; var Date: TDate);
var
  flag: boolean;
  temp: string;
begin
  flag := true;
  repeat
    write(AMessage);
    readln(temp);
    if not correctDate(temp) then
      writeln(AWrongMessage)
    else
      flag := false;
  until not flag;
  Date := StrToDate(temp);
end;

procedure InputTime(AMessage, AWrongMessage: String; var Time: TTime);
var
  flag: boolean;
  temp: string;
begin
  flag := true;
  repeat
    write(AMessage);
    readln(temp);
    if not correctTime(temp) then
      writeln(AWrongMessage)
    else
      flag := false;
  until not flag;
  Time := StrToTime(temp);
end;

procedure printTalonList(const Head: TTalonListPt);
var
  temp: TTalonListPt;
begin
  if Head^.next = nil then
    writeln('Список пуст');
  temp := head;
  while temp <> nil do
  begin
    writeln('Дата: ', DateToStr(temp^.Talon.date));
    writeln('Время: ', TimeToStr(temp^.Talon.time));
    writeln('№ в очереди: ', temp^.Talon.queuePos);
    writeln('ФИО пациента: ', temp^.Talon.patientLastName);
    writeln('Кабинет: ', temp^.Talon.cabNum);
    writeln('Код врача: ', temp^.Talon.docKey);
    writeln;
    temp := temp^.next;
  end;
end;

procedure printDocList(const Head: TDocListPt);
var
  temp: TDocListPt;
  i: TWeekDay;
begin
  if Head^.next = nil then
    writeln('Список пуст');
  temp := head;
  while temp <> nil do
  begin
    writeln('Код: ', temp^.Doc.docKey);
    writeln('Специализация: ', temp^.Doc.specialisation);
    writeln('ФИО врача: ', temp^.Doc.docLastName);
    writeln('График работы:');
    for i := Mon to Sat do
      writeln('  ', WeekNames[i], ': ', TimeToStr(temp^.Doc.Schedule[i].start), '-', TimeToStr(temp^.Doc.Schedule[i].finish));
    temp := temp^.next;
  end;
end;
//Компараторы поиска талонов
function searchCompDate(temp: TTalonListPt; const Value): boolean;
begin
  result := temp^.Talon.date = TDate(Value);
end;

function searchCompTime(temp: TTalonListPt; const Value): boolean;
begin
  result := temp^.Talon.time = TTime(Value);  
end;

function searchCompPatientLastName(temp: TTalonListPt; const Value): boolean;
begin
  result := temp^.Talon.patientLastName = String(Value);  
end;

function searchCompCabNum(temp: TTalonListPt; const Value): boolean;
begin
  result := temp^.Talon.cabNum = Integer(Value);  
end;
                                       
function searchCompDocKey(temp: TTalonListPt; const Value): boolean;
begin
  result := temp^.Talon.docKey = Integer(Value);  
end;

function SearchTalon(const Head: TTalonListPt; const Comp: TTalonSearchComp; const Value): TTalonArr;
var
  temp: TTalonListPt;
begin
  SetLength(result, 0);
  temp := head;
  while temp <> nil do
  begin
    if comp(temp, Value) then
    begin
      SetLength(result, length(result) + 1);
      result[High(result)] := temp;
    end;
    temp := temp^.next;
  end;
end;

procedure addTalon(const Head: TTalonListPt; Talon: TTalon);
var
  temp: TTalonListPt;
begin
  temp := head;
  while temp^.next <> nil do
    temp := temp^.next;
  New(temp^.next);
  temp^.next := nil;
  temp.Talon := Talon;
end;

procedure MainMenu;
begin
  writeln('Главное меню:');
  writeln('[1] - Чтение данных из файла.');
  writeln('[2] - Просмотр всего списка.');
  writeln('[3] - Сортировка данных.');
  writeln('[4] - Поиск данных.');
  writeln('[5] - Добавление данных в список.');
  writeln('[6] - Удаление данных из списка.');
  writeln('[7] - Редактирование данных.');
  writeln('[8] - Работа с талонами.');
  writeln('[9] - Выход без сохранения изменений.');
  writeln('[10] - Выход с сохранением изменений.');
end;

procedure chooseListMenu;
begin
  writeln('[1] - Список талонов.');
  writeln('[2] - Список врачей.');
  writeln('[3] - В главное меню.');
end;

begin
  readln;
end.
